#!/usr/bin/env python3
"""
Update material references in the database using arXiv snippets.

This script ingests JSON files generated by `arxiv_fetch.py` and injects the
metadata into the `references` field of the materials database entries.

Usage:
  python materials_lab/update_references.py \
    --db materials_lab/data/materials_db.json \
    --arxiv materials_lab/data/a304_arxiv.json \
            materials_lab/data/ti6al4v_arxiv.json
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Dict, List


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Add literature references to the materials database.")
    parser.add_argument(
        "--db",
        default="materials_lab/data/materials_db.json",
        help="Path to the materials database JSON file.",
    )
    parser.add_argument(
        "--arxiv",
        nargs="+",
        required=True,
        help="One or more JSON files produced by arxiv_fetch.py.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print changes without writing them back to the database.",
    )
    return parser.parse_args()


def load_json(path: Path) -> Dict:
    with path.open() as fh:
        return json.load(fh)


def build_reference_entries(arxiv_payload: Dict) -> List[Dict[str, str]]:
    material_label = arxiv_payload.get("material")
    references = []
    for item in arxiv_payload.get("results", []):
        references.append(
            {
                "source": "arXiv",
                "material_label": material_label,
                "title": item.get("title"),
                "published": item.get("published"),
                "summary": item.get("summary_snippet"),
                "link": item.get("link"),
                "query": item.get("query"),
                "notes": item.get("note", ""),
            }
        )
    return references


def inject_references(db: Dict[str, Dict], material_name: str, references: List[Dict[str, str]]) -> bool:
    key_variants = [
        material_name,
        material_name.replace(" ", ""),
        material_name.replace("-", ""),
        material_name.replace(" ", "-"),
        material_name.replace("-", " "),
    ]

    for key in key_variants:
        if key in db:
            entry = db[key]
            existing = entry.get("references", [])
            # Merge unique references by link
            links = {ref.get("link") for ref in existing if isinstance(ref, dict)}
            for ref in references:
                if ref.get("link") not in links:
                    existing.append(ref)
            entry["references"] = existing
            db[key] = entry
            return True
    return False


def main() -> None:
    args = parse_args()
    db_path = Path(args.db)
    db = load_json(db_path)

    updates_applied = []
    for arxiv_file in args.arxiv:
        payload = load_json(Path(arxiv_file))
        refs = build_reference_entries(payload)
        if not refs:
            continue
        success = inject_references(db, payload.get("material", ""), refs)
        updates_applied.append((arxiv_file, success, len(refs)))

    if args.dry_run:
        for filename, success, count in updates_applied:
            status = "updated" if success else "missing"
            print(f"[dry-run] {filename}: {status} ({count} refs)")
        return

    with db_path.open("w") as fh:
        json.dump(db, fh, indent=2)

    for filename, success, count in updates_applied:
        status = "updated" if success else "missing"
        print(f"[info] {filename}: {status} ({count} refs)")


if __name__ == "__main__":
    main()
